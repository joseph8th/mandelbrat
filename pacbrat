#!/usr/bin/env bash

### DEBUGGING ###
#set -x

#===========================================#
#                   SETUP                   #
#===========================================#

NOERR=0
FIND_PATH=1
SCRIPT=`basename $0`

source ./${SCRIPT}.d/util.sh                      # source search_path
source ./${SCRIPT}.d/bash_ini_parser/read_ini.sh  # source bash cfg parser
read_ini ./${SCRIPT}.d/${SCRIPT}.cfg -p CFG       # read python-compatible INI

# custom install/uninstall functions
if [ -e ./${SCRIPT}.d/${SCRIPT}_custom.sh ]; then
    source ./${SCRIPT}.d/${SCRIPT}_custom.sh
fi

# split $PATH for search_path function
OLDIFS=$IFS

IFS=:
DIRS=
read DIRS <<END
$PATH
END

IFS=$OLDIFS

# Error logging
function _err {
    let NOERR=NOERR+1
}

function _printerr {
    echo "==> ERROR (${NOERR}): try after fixing (${NOERR}) problems."
}


#### Command line option functions. ####

# shell based installer
function _run_shinstall {

    echo "Installing '${CFG__PROG__PROG}' ..."
    # make sure it's not already installed correctly
    if  [[ -e "${CFG__INSTALL__DEF_ROOTD}" ]] && \
        [[ -e "${CFG__INSTALL__DEF_COMMANDD}/${CFG__PROG__PROG}" ]]; then
        echo "==> ERROR: ${CFG__PROG__PROG} is installed. Uninstall first."
        _err; return
    fi

    # run any custom pre-installation
    [ ! -z $CUSTOM_PREINSTALL ] && $CUSTOM_PREINSTALL
    [[ "$NOERR" != "0" ]] && _err && _printerr && return

    # run any custom installation
    [ ! -z $CUSTOM_INSTALL ] && $CUSTOM_INSTALL
    [[ "$NOERR" != "0" ]] && _err && _printerr && return

    # run any custom post-installation
    [ ! -z $CUSTOM_POSTINSTALL ] && $CUSTOM_POSTINSTALL
    [[ "$NOERR" != "0" ]] && _err && _printerr && return

    # now install the user command 
    echo "Make command '${CFG__PROG__PROG}': ${CFG__INSTALL__DEF_COMMANDD}"
    sudo ln -s "${CFG__INSTALL__DEF_MAINF}" \
        "${CFG__INSTALL__DEF_COMMANDD}/${CFG__PROG__PROG}"

}


# shell based uninstaller
function _run_shuninstall {

    echo "Uninstalling '${CFG__PROG__PROG}' ..."

    # make sure it's installed
    if  [[ ! -e "${CFG__INSTALL__DEF_ROOTD}" ]] && \
        [[ ! -e "${CFG__INSTALL__DEF_COMMANDD}/${CFG__PROG__PROG}" ]]; then
        echo "Not installed. Nothing to do."
        return
    fi

    # run any custom pre-installation
    [ ! -z $CUSTOM_PREUNINSTALL ] && $CUSTOM_PREUNINSTALL
    [[ "$NOERR" != "0" ]] && _err && _printerr && return

    # run any custom installation
    [ ! -z $CUSTOM_UNINSTALL ] && $CUSTOM_UNINSTALL
    [[ "$NOERR" != "0" ]] && _err && _printerr && return

    # run any custom post-installation
    [ ! -z $CUSTOM_POSTUNINSTALL ] && $CUSTOM_POSTUNINSTALL
    [[ "$NOERR" != "0" ]] && _err && _printerr && return

}


# delete user project directory if it exists
function _run_shdelete {

    echo "Removing user project directory ..."

    if [ -z $DEF_USRD ]; then
        echo "No user project directory exists for this package."
        return
    fi

    rm -rf "$DEF_USRD"

}


# help function
function _run_help {
    echo "usage: ${SCRIPT} [-h | -i | -r | -u | -d]"
    printf "See 'README.md' for more information."
}


# parse command line options
function _parse_opts {
    OPTIND=1
    while getopts "hirud" opt; do
        case "$opt" in
            h)
                _run_help
                exit 1
                ;;
            i)
                _run_shinstall
                exit $NOERR
                ;;
            r) 
                _run_shuninstall
                [[ "${NOERR}" ==  "0" ]] && _run_shinstall
                exit $NOERR
                ;;
            u)
                _run_shuninstall
                exit $NOERR
                ;;
            d)
                _run_shdelete
                exit $NOERR
                ;;
        esac
    done
    
    # otherwise spit out help
    _run_help
    exit 1
}


#===========================================#
#                    MAIN                   #
#===========================================#

# parse command line options and execute
_parse_opts $*
exit $NOERR
